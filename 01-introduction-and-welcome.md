# üéâ Welcome to Fundamentals of Database Systems: From Queries to Internals

> **Welcome!** üëã This course, 'Fundamentals of Database Systems: From Queries to Internals', is your deep dive into the world of database engineering. Whether you're a backend developer, tech lead, or just database-curious, you're about to embark on a journey that will transform how you think about data systems.

---

## üìö Table of Contents

1. [Course Overview](#course-overview)
2. [How to Use This Course](#how-to-use-this-course)
3. [Why This Course Exists](#why-this-course-exists)
4. [Who This Course Is For](#who-this-course-is-for)
5. [What You'll Learn: The Core Pillars](#what-youll-learn-the-core-pillars)
6. [What You Won't Learn](#what-you-wont-learn)
7. [What Makes This Course Different?](#what-makes-this-course-different)
8. [How to Navigate This Course](#how-to-navigate-this-course)
9. [Final Thoughts Before You Dive In](#final-thoughts-before-you-dive-in)

---

## üìö Course Overview

**What is this course?**
- A practical, engineering-focused guide to how real-world databases are designed, optimized, and maintained.
- Not just SQL syntax or product walkthroughs, but the *why* and *how* behind the scenes.
- Built for the curious: you'll learn to think like a system designer, not just a database user.

**What will you learn?**
- The core pillars of database engineering: ACID, indexing, partitioning, sharding, concurrency, engines, replication, security, and more.
- How to architect resilient, scalable, and high-performance data systems.
- Real-world scenarios, trade-offs, and design patterns used by top engineers.

**Who is this for?**
- Developers who know basic SQL and want to go deeper.
- Engineers aiming to level up their database intuition and architectural skills.
- Anyone who wants to understand *why* databases work the way they do.

**Prerequisites:**
- You should be comfortable with basic SQL (SELECT, INSERT, UPDATE, DELETE).
- Familiarity with at least one relational database (e.g., PostgreSQL, MySQL) is helpful.
- Curiosity and a willingness to experiment!

---

## üß≠ How to Use This Course

- **Start at the beginning** for the best experience, but feel free to jump to topics that interest you.
- Each chapter ends with a **Quiz Time! üß†** section to reinforce your learning.
- Use the navigation links at the bottom to move between chapters or return to the course index.
- Treat this as a reference‚Äîreturn as your career evolves!

---

## üîç Why This Course Exists

If you've ever wondered how real-world database systems are designed and maintained, this course is for you.

This isn't your typical beginner's SQL tutorial or a walkthrough of PostgreSQL syntax. It's something deeper ‚Äî a course built on curiosity, real-world scenarios, and a passion for exploring how things work under the hood. Think of it less like a checklist of skills and more like a guided expedition into the engineering mindsets behind modern database systems.

This is the course I wish I had when I was starting out. One that bridges the gap between what you learn in school and what engineers are actually doing in production.

---

## üß≠ Who This Course Is For

This course is **not** for someone who has never written a SQL query or doesn't know what a database is. If you're looking for SQL basics, there are plenty of beginner resources out there. This course picks up after that.

This course is designed for:
- Junior developers who know the basics of databases and want to go deeper.
- Backend engineers looking to level up their architectural thinking.
- Tech leads and architects seeking to strengthen their database intuition.
- Anyone curious about why systems work the way they do.

---

## üß± What You'll Learn: The Core Pillars

We break down the wide field of database engineering into focused, digestible parts. Each section is topic-based, not tool-based. Our focus is first principles and architecture, not tutorials on specific products.

Here's a snapshot of what we'll cover:

1. **ACID Principles**  
   Dive deep into atomicity, consistency, isolation, and durability. Not just the definitions, but how they affect design decisions and trade-offs in production.

2. **Indexing & Query Optimization**  
   Understand indexing strategies, why they exist, and how databases use them behind the scenes.

3. **Partitioning vs. Sharding**  
   Learn the difference, the use cases for each, and when to scale horizontally.

4. **Concurrency Control**  
   Explore transaction isolation levels, deadlocks, and real-world locking scenarios.

5. **Database Engines & Internals**  
   Discover how database engines differ (e.g., InnoDB vs. RocksDB), how pages are stored and fetched, and what execution engines actually do.

6. **Replication & High Availability**  
   Understand master-replica setups, read scalability, and data consistency guarantees.

7. **Security, Encryption & Homomorphic Queries**  
   Explore emerging techniques like searching encrypted data and learn what true database security means beyond "use SSL."

8. **System Design & Real-World Scenarios**  
   Apply what you learn by walking through database designs for actual applications (e.g., a URL shortener, social app, etc.).

---

## üß† What You Won't Learn
- This is not a "PostgreSQL for Beginners" course.
- We don't teach ORMs or UI frameworks.
- We won't cover every single SQL clause.

**Why?** Because those are tools ‚Äî easy to learn once you understand the *why* behind database behavior. Our goal is to empower you to choose the right tools and design resilient systems, not memorize features.

---

## üß® What Makes This Course Different?
- **It's engineered for curiosity.** You won't just learn what something does ‚Äî we'll ask why it exists in the first place.
- **You'll think like a system designer.** By the end, you won't just use databases ‚Äî you'll architect them.
- **It's modular.** Each topic stands on its own, so you can revisit sections as your needs evolve.
- **It evolves over time.** This course has grown from a 6-hour series to 14+ hours of advanced content ‚Äî and counting ‚Äî based on feedback and questions from thousands of learners.

---

## üó∫Ô∏è How to Navigate This Course

We recommend starting from the beginning, but feel free to skip around based on your experience level. Here's how we've structured the journey:
- **Foundation:** ACID, database internals, and storage mechanisms.
- **Core Concepts:** Indexing, partitioning, concurrency, sharding.
- **Advanced Topics:** Replication, encryption, system design walkthroughs.
- **Ongoing Discussions:** Q&A sections and lecture-based answers to common student questions.

If something feels unclear early on ‚Äî don't worry. Concepts like B-Trees or MVCC will make more sense after understanding database internals. You'll keep building mental models over time.

---

## üß© Final Thoughts Before You Dive In

Learning how databases work is transformational. It will change how you write queries, how you design applications, and how you think about performance, security, and scale.

So treat this course like a reference book ‚Äî something to return to as your career evolves. Don't rush. Don't just read. Think.

Start asking:
- Why does this concept exist?
- What problems does it solve?
- How would I apply it to my own system?

**This is where real learning happens.**

---

[‚¨ÖÔ∏è Previous: Course Index](README.md) | 
[‚û°Ô∏è Next: ACID Properties in Database Systems](02-acid-properties.md)